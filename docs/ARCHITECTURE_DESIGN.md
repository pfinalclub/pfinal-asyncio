# pfinal-asyncio 架构设计文档

## 目录

1. [架构概述](#架构概述)
2. [设计原则](#设计原则)
3. [核心组件](#核心组件)
4. [模块划分](#模块划分)
5. [数据流](#数据流)
6. [设计决策](#设计决策)
7. [性能优化](#性能优化)
8. [可扩展性](#可扩展性)
9. [可靠性](#可靠性)
10. [安全性](#安全性)
11. [监控与可观测性](#监控与可观测性)
12. [部署与运行](#部署与运行)

## 架构概述

pfinal-asyncio 是一个基于 PHP 8.1+ Fibers 的异步运行时内核，专注于解决异步运行时问题，提供轻量级、可嵌入、可组合的异步编程体验。

### 架构层次

pfinal-asyncio 采用分层架构，从底层到上层依次为：

1. **事件驱动层**：基于 Workerman 实现的高性能事件循环
2. **核心抽象层**：Fiber 管理、任务状态管理、事件循环接口
3. **结构化并发层**：CancellationScope、TaskGroup、gather 策略
4. **资源管理层**：异步资源生命周期管理
5. **可观测性层**：事件发布订阅机制
6. **API层**：核心函数 API，提供简洁易用的编程接口

### 架构图

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                                 API 层                                      │
├─────────────────────────────────────────────────────────────────────────────┤
│         create_task() | await() | sleep() | gather() | run()               │
└───────────────────────────────────┬─────────────────────────────────────────┘
                                    │
┌───────────────────────────────────▼─────────────────────────────────────────┐
│                           结构化并发层                                      │
├─────────────────────────────────────────────────────────────────────────────┤
│  CancellationScope  |  TaskGroup  |  GatherStrategy  |  Semaphore           │
└───────────────────────────────────┬─────────────────────────────────────────┘
                                    │
┌───────────────────────────────────▼─────────────────────────────────────────┐
│                             核心抽象层                                      │
├─────────────────────────────────────────────────────────────────────────────┤
│  EventLoop | Task | TaskState | Future | Context | PriorityScheduler        │
└───────────────────────────────────┬─────────────────────────────────────────┘
                                    │
┌───────────────────────────────────▼─────────────────────────────────────────┐
│                            资源管理层                                      │
├─────────────────────────────────────────────────────────────────────────────┤
│  AsyncResource | AsyncResourceManager | FiberResource | TimerResource        │
└───────────────────────────────────┬─────────────────────────────────────────┘
                                    │
┌───────────────────────────────────▼─────────────────────────────────────────┐
│                            可观测性层                                      │
├─────────────────────────────────────────────────────────────────────────────┤
│  Observable | Observer | TaskEvent | ScopeEvent | ResourceEvent             │
└───────────────────────────────────┬─────────────────────────────────────────┘
                                    │
┌───────────────────────────────────▼─────────────────────────────────────────┐
│                           事件驱动层                                      │
├─────────────────────────────────────────────────────────────────────────────┤
│                 Workerman | EventLoopBackend (Ev/Event/Select)             │
└─────────────────────────────────────────────────────────────────────────────┘
```

## 设计原则

### 核心设计理念

pfinal-asyncio 遵循以下核心设计理念：

- **最小化**：只解决异步运行时问题，不涉及业务逻辑
- **可嵌入**：轻量级，零侵入，易于集成到现有项目
- **可组合**：清晰的组件边界，接口驱动设计，便于组合使用
- **可推理**：可预测的行为，状态管理执行，便于调试和维护
- **高性能**：基于 PHP 8.1+ Fibers，上下文切换开销小
- **稳定性**：完善的错误处理和资源管理机制

### 具体设计原则

1. **接口驱动设计**：定义清晰的接口，实现与接口分离，便于扩展和替换实现
2. **单一职责原则**：每个组件只负责一个职责，便于维护和测试
3. **开闭原则**：对扩展开放，对修改关闭
4. **依赖倒置原则**：依赖于抽象，不依赖于具体实现
5. **状态管理原则**：每个任务都有明确的状态，状态转换有明确的规则
6. **资源管理原则**：所有资源都有明确的生命周期，确保资源在不再使用时被正确释放
7. **错误处理原则**：完善的错误传播和异常处理机制
8. **可观测性原则**：提供事件发布订阅机制，便于监控和调试

## 核心组件

### 事件循环 (EventLoop)

事件循环是异步运行时的核心，负责调度和执行异步任务。事件循环基于 Workerman 实现，支持多种事件循环后端（Ev、Event、Select）。

#### 主要功能

- 管理和调度异步任务
- 处理定时器事件
- 管理事件驱动的 IO 操作
- 支持多种事件循环后端
- 提供稳定的事件循环接口

#### 设计特点

- **单例模式**：确保全局唯一的事件循环实例
- **延迟初始化**：事件循环在第一次使用时初始化
- **自动选择最优后端**：根据系统环境自动选择最优的事件循环后端
- **零轮询设计**：完全事件驱动，无轮询，减少 CPU 占用
- **高性能**：基于 Workerman 实现，性能优异

### 任务 (Task)

任务是对 Fiber 的封装，管理异步操作的生命周期。每个任务都有明确的状态，由 TaskState 枚举管理。

#### 主要功能

- 封装 Fiber，提供统一的任务管理接口
- 管理任务的生命周期状态
- 支持任务取消
- 支持任务完成回调
- 支持异常传播

#### 设计特点

- **类型安全的状态管理**：使用 TaskState 枚举管理任务状态
- **状态转换验证**：确保任务状态转换的合法性
- **自动清理机制**：任务完成后自动清理资源
- **可观测性**：任务状态变化时触发事件

### 结构化并发

结构化并发是一种并发编程范式，确保并发操作的可预测性和可维护性。pfinal-asyncio 提供了 CancellationScope、TaskGroup 和 gather 策略来支持结构化并发。

#### CancellationScope

CancellationScope 管理任务的取消和资源清理，确保所有任务都在明确的作用域内执行。

##### 主要功能

- 管理作用域内的任务
- 支持作用域取消
- 支持嵌套作用域
- 自动清理作用域内的资源

##### 设计特点

- **自动资源管理**：作用域完成后自动清理资源
- **取消传播**：作用域取消会传播到所有关联的任务
- **当前作用域获取**：支持获取当前活动的作用域
- **嵌套支持**：支持嵌套作用域，形成作用域树

#### TaskGroup

TaskGroup 管理一组相关的任务，提供统一的任务管理和等待机制。

##### 主要功能

- 管理一组相关的任务
- 支持等待所有任务完成
- 支持批量取消任务
- 支持获取任务状态

##### 设计特点

- **批量管理**：统一管理一组任务
- **灵活的等待机制**：支持等待所有任务完成
- **高效取消**：支持批量取消任务
- **状态监控**：支持获取任务组的状态

#### gather 策略

gather 策略定义了并发运行多个任务时的行为，支持三种策略：FAIL_FAST、WAIT_ALL 和 RETURN_PARTIAL。

##### 主要功能

- 并发运行多个任务
- 支持不同的失败处理策略
- 聚合任务结果和异常
- 提供详细的失败信息

##### 设计特点

- **灵活的策略支持**：支持三种不同的失败处理策略
- **详细的异常信息**：提供 GatherException，包含所有任务的结果和异常
- **高效执行**：并发执行任务，提高执行效率
- **类型安全**：使用 GatherStrategy 枚举，确保类型安全

### 资源管理 (Resource Management)

资源管理负责管理异步资源的生命周期，确保资源在不再使用时被正确释放。

#### 主要功能

- 管理异步资源的生命周期
- 支持资源注册和注销
- 支持批量资源管理
- 支持资源泄漏检测
- 支持资源自动清理

#### 设计特点

- **统一的资源接口**：所有资源实现 AsyncResource 接口
- **自动清理机制**：资源在不再使用时自动释放
- **泄漏检测**：支持检测资源泄漏
- **批量操作支持**：支持资源的批量注册和注销
- **可观测性**：资源状态变化时触发事件

### 可观测性 (Observability)

可观测性允许监控和调试异步运行时，提供事件发布订阅机制。

#### 主要功能

- 事件发布订阅机制
- 支持任务、作用域和资源事件
- 支持观察者注册和注销
- 支持事件过滤
- 支持零开销观测

#### 设计特点

- **零开销默认**：默认关闭可观测性，不影响性能
- **灵活的事件类型**：支持多种事件类型，便于监控和调试
- **高效的事件发布**：事件发布采用高效的实现，减少性能开销
- **可扩展的观察者机制**：支持自定义观察者

## 模块划分

### Core 模块

Core 模块包含核心抽象和实现，是异步运行时的基础。

#### 包含的文件

- **EventLoopInterface.php**：事件循环的稳定接口
- **EventLoop.php**：事件循环的实现
- **Task.php**：任务管理
- **TaskState.php**：任务状态枚举
- **PriorityScheduler.php**：三级调度器
- **SchedulerInterface.php**：调度器接口

#### 主要功能

- 事件循环管理
- 任务生命周期管理
- 任务状态管理
- 三级调度模型
- 核心 API 定义

### Concurrency 模块

Concurrency 模块提供结构化并发支持，包括 CancellationScope、TaskGroup 和 gather 策略。

#### 包含的文件

- **CancellationScope.php**：取消作用域
- **TaskGroup.php**：任务组管理
- **GatherStrategy.php**：gather 策略

#### 主要功能

- 结构化并发支持
- 任务取消管理
- 任务组管理
- gather 策略支持

### Resource 模块

Resource 模块负责管理异步资源的生命周期。

#### 包含的文件

- **AsyncResource.php**：资源接口
- **AsyncResourceManager.php**：资源管理器
- **Context.php**：上下文管理
- **ContextResource.php**：上下文资源
- **FiberResource.php**：Fiber 资源
- **TimerResource.php**：定时器资源

#### 主要功能

- 资源生命周期管理
- 资源自动清理
- 资源泄漏检测
- 上下文管理
- 协程本地变量

### Observable 模块

Observable 模块提供事件发布订阅机制，支持监控和调试异步运行时。

#### 包含的文件

- **Observer.php**：观察者接口
- **Observable.php**：可观测性管理器
- **Events/TaskEvent.php**：任务事件
- **Events/ScopeEvent.php**：作用域事件

#### 主要功能

- 事件发布订阅机制
- 任务事件监控
- 作用域事件监控
- 资源事件监控
- 观察者管理

### Exception 模块

Exception 模块包含异步运行时的异常类。

#### 包含的文件

- **GatherException.php**：gather 异常
- **TimeoutException.php**：超时异常
- **TaskCancelledException.php**：任务取消异常

#### 主要功能

- 异常定义
- 异常信息聚合
- 详细的错误信息
- 便于调试和错误处理

### Internal 模块

Internal 模块包含内部实现细节，不对外暴露。

#### 包含的文件

- **Future.php**：Future 实现

#### 主要功能

- 内部实现细节
- 不对外暴露的功能
- 辅助功能实现

## 数据流

### 任务创建和执行流程

1. 用户通过 `create_task()` 函数创建任务
2. `create_task()` 函数调用 EventLoop 的 `createFiber()` 方法
3. `createFiber()` 方法创建 Fiber 和 Task 对象
4. Task 对象被添加到当前 CancellationScope
5. Task 对象的状态设置为 PENDING
6. EventLoop 调度 Task 执行
7. Task 状态变为 RUNNING
8. Task 执行完成，状态变为 COMPLETED 或 FAILED
9. Task 触发完成事件
10. Task 被从 CancellationScope 中移除
11. Task 资源被自动清理

### 事件处理流程

1. 用户通过 `addTimer()` 方法添加定时器
2. 定时器事件被添加到事件循环
3. 定时器触发时，事件循环调用回调函数
4. 回调函数执行，可以创建新的任务或触发其他事件
5. 事件处理完成

### 资源管理流程

1. 用户创建实现 AsyncResource 接口的资源
2. 通过 AsyncResourceManager 注册资源
3. 资源被关联到当前 CancellationScope
4. 资源状态变为 ACTIVE
5. CancellationScope 完成时，资源被自动清理
6. 资源状态变为 CLOSED
7. 资源触发关闭事件

## 设计决策

### 事件循环设计决策

#### 单例模式

事件循环采用单例模式，确保全局唯一的事件循环实例。

**优势**：
- 确保全局唯一的事件循环，避免冲突
- 简化 API 设计，便于使用
- 减少资源消耗

**劣势**：
- 限制了多事件循环场景的使用
- 增加了全局状态

#### 自动选择最优后端

事件循环自动选择最优的事件循环后端，根据系统环境自动选择 Ev、Event 或 Select。

**优势**：
- 提高性能，充分利用系统资源
- 简化用户配置，无需手动选择后端
- 提高跨平台兼容性

**劣势**：
- 增加了初始化逻辑的复杂度
- 可能导致不同环境下的行为差异

### 任务管理设计决策

#### 类型安全的状态管理

任务状态使用 TaskState 枚举管理，确保类型安全和状态转换的合法性。

**优势**：
- 类型安全，避免无效状态
- 明确的状态转换规则
- 便于调试和监控

**劣势**：
- 增加了代码复杂度
- 可能限制了灵活性

#### 自动清理机制

任务完成后自动清理资源，确保资源在不再使用时被正确释放。

**优势**：
- 减少资源泄漏风险
- 简化用户代码
- 提高系统稳定性

**劣势**：
- 增加了任务执行的开销
- 可能导致意外的资源清理

### 结构化并发设计决策

#### CancellationScope

CancellationScope 管理任务的取消和资源清理，确保所有任务都在明确的作用域内执行。

**优势**：
- 明确的任务作用域
- 自动资源管理
- 支持任务取消传播

**劣势**：
- 增加了代码复杂度
- 可能导致意外的任务取消

#### gather 策略

gather 支持三种策略：FAIL_FAST、WAIT_ALL 和 RETURN_PARTIAL。

**优势**：
- 灵活的失败处理策略
- 详细的异常信息
- 高效的并发执行

**劣势**：
- 增加了 API 复杂度
- 可能导致意外的行为

### 资源管理设计决策

#### AsyncResource 接口

所有异步资源都实现 AsyncResource 接口，确保统一的资源管理。

**优势**：
- 统一的资源管理接口
- 便于扩展和替换实现
- 自动资源清理

**劣势**：
- 增加了代码复杂度
- 可能限制了灵活性

#### 资源泄漏检测

提供资源泄漏检测功能，便于监控和调试。

**优势**：
- 便于检测资源泄漏
- 提高系统稳定性
- 便于调试

**劣势**：
- 增加了运行时开销
- 可能产生误报

### 可观测性设计决策

#### 零开销默认

可观测性默认关闭，不影响性能。

**优势**：
- 不影响正常运行时的性能
- 便于在生产环境中部署
- 可以根据需要启用

**劣势**：
- 增加了代码复杂度
- 可能导致调试时需要额外的配置

## 性能优化

### 事件驱动设计

采用完全事件驱动的设计，无轮询，减少 CPU 占用。

### 高效的 Fiber 管理

基于 PHP 8.1+ Fibers 实现，上下文切换开销小，性能优异。

### 三级调度模型

实现了 SYSTEM、CONTROL 和 WORK 三级调度模型，确保不同优先级任务的合理调度。

### 延迟清理机制

采用延迟清理机制，减少频繁清理的开销，提高性能。

### 批量操作优化

支持批量资源注册和注销，减少函数调用开销。

### 可观测性优化

可观测性默认关闭，不影响性能，需要时可以启用。

### 内存使用优化

实现了完善的资源管理和自动清理机制，减少内存泄漏风险。

### 事件循环优化

基于 Workerman 实现，性能优异，支持多种事件循环后端。

## 可扩展性

### 接口驱动设计

采用接口驱动设计，便于扩展和替换实现。

### 模块化设计

采用模块化设计，各模块职责明确，耦合度低，便于扩展。

### 可扩展的资源管理

支持自定义资源类型，实现 AsyncResource 接口即可集成到资源管理系统。

### 可扩展的可观测性

支持自定义观察者，便于扩展监控和调试功能。

### 可扩展的调度器

支持自定义调度器，实现 SchedulerInterface 接口即可集成到系统中。

## 可靠性

### 完善的错误处理

提供完善的错误处理和异常传播机制，确保系统在错误情况下的可靠性。

### 资源管理机制

实现了完善的资源管理机制，确保资源在不再使用时被正确释放。

### 状态管理

采用类型安全的状态管理，确保系统状态的一致性和可靠性。

### 可观测性

提供可观测性机制，便于监控和调试系统，提高系统的可靠性。

### 测试覆盖

实现了全面的测试覆盖，确保系统的可靠性和稳定性。

## 安全性

### 资源隔离

采用 CancellationScope 机制，确保资源的隔离和安全管理。

### 异常处理

提供完善的异常处理机制，避免错误传播和系统崩溃。

### 输入验证

对所有输入进行严格验证，避免非法输入导致的安全问题。

### 资源限制

实现了资源限制机制，避免资源滥用和系统崩溃。

### 安全的类型系统

采用类型安全的设计，避免类型错误导致的安全问题。

## 监控与可观测性

### 事件发布订阅机制

提供事件发布订阅机制，便于监控和调试系统。

### 任务事件

监控任务的创建、执行、完成、失败和取消事件。

### 作用域事件

监控作用域的创建、完成和取消事件。

### 资源事件

监控资源的注册、注销、关闭和泄漏事件。

### 性能统计

提供性能统计信息，便于监控系统性能。

### 日志记录

提供详细的日志记录，便于调试和故障排除。

## 部署与运行

### 部署环境

- PHP 8.1+
- 支持 Fibers
- 可选：ev 或 event 扩展，提高性能

### 安装方式

通过 Composer 安装：

```bash
composer require pfinalclub/asyncio
```

### 运行方式

#### 单进程模式

```php
<?php
require_once __DIR__ . '/vendor/autoload.php';

use function PfinalClubsynciorun, sleep};

run(function() {
    echo "Hello, AsyncIO!\n";
    sleep(1);
    echo "Goodbye, AsyncIO!\n";
});
```

#### 多进程模式

结合 Workerman 等多进程框架使用：

```php
<?php
require_once __DIR__ . '/vendor/autoload.php';

use Workerman\Worker;
use function PfinalClubsynciorun, sleep};

$worker = new Worker('tcp://0.0.0.0:8080');
$worker->count = 4;

$worker->onMessage = function($connection, $data) {
    run(function() use ($connection, $data) {
        $connection->send("Received: {$data}\n");
        sleep(1);
        $connection->send("Processed: {$data}\n");
    });
};

Worker::runAll();
```

### 最佳实践

1. **使用结构化并发**：尽量使用 CancellationScope、TaskGroup 和 gather 策略来管理并发操作
2. **注册资源**：确保所有异步资源都通过 AsyncResourceManager 注册
3. **处理异常**：使用 try-catch 块处理异步操作可能抛出的异常
4. **使用适当的优先级**：根据任务的重要性和紧急程度，使用适当的优先级
5. **监控和调试**：在开发和调试阶段，启用可观测性
6. **使用高性能事件循环**：安装 ev 或 event 扩展，提高性能
7. **优化资源使用**：及时释放不再使用的资源，减少内存占用
8. **避免长时间运行的任务**：将长时间运行的任务拆分为多个短任务

## 总结

pfinal-asyncio 是一个设计优良的异步运行时内核，具有以下特点：

- **高性能**：基于 PHP 8.1+ Fibers，上下文切换开销小
- **轻量级**：专注于解决异步运行时问题，不涉及业务逻辑
- **可嵌入**：易于集成到现有项目
- **可组合**：清晰的组件边界，便于组合使用
- **可推理**：可预测的行为，便于调试和维护
- **可靠性**：完善的错误处理和资源管理机制
- **可观测性**：提供事件发布订阅机制，便于监控和调试

pfinal-asyncio 采用分层架构，从底层到上层依次为事件驱动层、核心抽象层、结构化并发层、资源管理层、可观测性层和 API 层。各层职责明确，耦合度低，便于扩展和维护。

pfinal-asyncio 遵循最小化、可嵌入、可组合、可推理的设计理念，为 PHP 生态提供了一个可靠的异步运行时内核。
