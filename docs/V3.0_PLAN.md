# pfinal-asyncio v3.0 实施计划

## 核心目标

将 pfinal-asyncio 重构为 PHP 生态中"可长期依赖的 async runtime 内核"，严格遵循"只解决 async runtime 问题，其它一律不碰"的原则。

## 架构设计

### 模块划分

```
src/
├── Core/                    # 核心抽象（冻结）
│   ├── EventLoopInterface.php  # 冻结接口
│   ├── EventLoop.php          # 实现（可变化）
│   ├── Task.php              # 一等公民
│   ├── TaskState.php         # 状态枚举
│   └── functions.php         # 核心函数
│
├── Concurrency/              # 结构化并发
│   ├── CancellationScope.php # 取消作用域
│   ├── TaskGroup.php         # 任务组
│   ├── GatherStrategy.php    # gather 策略
│   └── Semaphore.php         # 信号量（保留）
│
├── Resource/                 # Runtime 资源管理
│   ├── AsyncResource.php    # 资源接口
│   └── AsyncResourceManager.php # 资源管理器
│
├── Observable/              # Runtime 可观测性
│   ├── Observer.php         # 观察者接口
│   ├── Observable.php       # 可观测性管理器
│   └── Events/              # 事件定义
│       ├── TaskEvent.php
│       ├── ScopeEvent.php
│       └── ResourceEvent.php
│
├── Exception/                # 异常处理
│   ├── GatherException.php
│   ├── TimeoutException.php
│   └── TaskCancelledException.php
│
└── Internal/                # 内部实现
    ├── FiberManager.php     # Fiber 管理
    └── ScopeTracker.php     # Scope 追踪
```

## 实施阶段

### Phase 1: 核心抽象冻结（2-3周）

#### 1.1 EventLoop 接口冻结

**文件**: `src/Core/EventLoopInterface.php` (新建), `src/Core/EventLoop.php` (重构)

**任务**:
- [ ] 创建 `EventLoopInterface` 接口，定义冻结的 API
- [ ] 将 `EventLoop` 类标记为实现类
- [ ] 将内部方法标记为 `@internal`
- [ ] 移除或隐藏 `getActiveFibers()` 等内部方法
- [ ] 添加 `@api-stable` 注解到稳定 API

**关键变更**:
```php
// 新增接口
interface EventLoopInterface {
    public static function getInstance(): self;
    public function run(callable $main): mixed;
    public function addTimer(float $interval, callable $callback, bool $persistent = true): int;
    public function delTimer(int $timerId): void;
    public function stop(): void;
    public static function getEventLoopType(): ?string;
}

// EventLoop 实现接口
final class EventLoop implements EventLoopInterface {
    // 内部方法标记为 @internal
    /**
     * @internal
     */
    private function getActiveFibers(): array { ... }
}
```

#### 1.2 Task 模型强化

**文件**: `src/Core/Task.php`, `src/Core/TaskState.php`

**任务**:
- [ ] 强化 `TaskState` 枚举，添加状态转换验证
- [ ] 在 `Task` 中添加状态转换验证逻辑
- [ ] 添加 `scope` 属性，强制 Task 属于 Scope
- [ ] 添加状态转换方法 `setState()` 并验证合法性
- [ ] 更新 `Task::setResult()` 和 `Task::setException()` 使用新的状态转换

**关键变更**:
```php
// TaskState 添加转换验证
enum TaskState: string {
    public function canTransitionTo(TaskState $target): bool { ... }
}

// Task 添加 scope 和状态验证
class Task {
    private ?CancellationScope $scope = null;
    private function setState(TaskState $newState): void {
        if (!$this->state->canTransitionTo($newState)) {
            throw new \RuntimeException("Invalid state transition");
        }
        $this->state = $newState;
    }
}
```

#### 1.3 核心函数冻结

**文件**: `src/Core/functions.php`

**任务**:
- [ ] 为所有核心函数添加 `@api-stable` 注解
- [ ] 标记实验性函数为 `@api-experimental`
- [ ] 废弃 `async()` 函数（使用 `create_task()`）
- [ ] 确保所有核心函数通过 EventLoop 接口操作

### Phase 2: 结构化并发（3-4周）

#### 2.1 CancellationScope 实现

**文件**: `src/Concurrency/CancellationScope.php` (新建)

**任务**:
- [ ] 实现 `CancellationScope` 类
- [ ] 实现 `run()` 静态方法（作用域运行）
- [ ] 实现 `current()` 静态方法（获取当前 Scope）
- [ ] 实现 `cancel()` 方法（取消作用域）
- [ ] 实现 `isCancelled()` 方法（检查取消状态）
- [ ] 实现任务注册/注销机制
- [ ] 实现父子 Scope 关系追踪

**关键实现**:
```php
class CancellationScope {
    private static ?CancellationScope $current = null;
    private bool $cancelled = false;
    private array $tasks = [];
    
    public static function run(callable $callback): mixed {
        $scope = new self();
        $scope->parent = self::$current;
        self::$current = $scope;
        try {
            return $callback($scope);
        } finally {
            $scope->cancel();
            self::$current = $scope->parent;
        }
    }
}
```

#### 2.2 TaskGroup 实现

**文件**: `src/Concurrency/TaskGroup.php` (新建)

**任务**:
- [ ] 实现 `TaskGroup` 类
- [ ] 实现 `spawn()` 方法（创建子任务）
- [ ] 实现 `waitAll()` 方法（等待所有任务）
- [ ] 实现 `cancel()` 方法（取消所有任务）
- [ ] 实现自动清理机制（任务完成时自动注销）
- [ ] 集成 `CancellationScope`

#### 2.3 禁止孤儿 Task

**文件**: `src/Core/EventLoop.php`, `src/Core/functions.php`

**任务**:
- [ ] 修改 `create_task()` 自动注册到当前 Scope
- [ ] 如果没有当前 Scope，创建默认 Scope 或抛出异常
- [ ] 实现孤儿 Task 检测机制（开发模式）
- [ ] 添加运行时警告（检测到孤儿 Task 时）

**关键实现**:
```php
function create_task(callable $callback, string $name = ''): Task {
    $scope = CancellationScope::current();
    if (!$scope) {
        // 创建默认 Scope 或抛出异常
        throw new \RuntimeException("No active CancellationScope");
    }
    $task = EventLoop::getInstance()->createFiber($callback, $name);
    $scope->registerTask($task);
    return $task;
}
```

#### 2.4 gather 语义收紧

**文件**: `src/Concurrency/GatherStrategy.php` (新建), `src/Core/functions.php`

**任务**:
- [ ] 创建 `GatherStrategy` 枚举（FAIL_FAST, WAIT_ALL, RETURN_PARTIAL）
- [ ] 修改 `gather()` 函数支持策略参数
- [ ] 实现 FAIL_FAST 策略（失败即取消）
- [ ] 实现 WAIT_ALL 策略（等待所有完成）
- [ ] 实现 RETURN_PARTIAL 策略（返回部分结果）
- [ ] 更新 `GatherException` 支持新策略

### Phase 3: Runtime 资源管理（2-3周）

#### 3.1 AsyncResource 接口

**文件**: `src/Resource/AsyncResource.php` (新建)

**任务**:
- [ ] 定义 `AsyncResource` 接口
- [ ] 定义 `close()` 方法
- [ ] 定义 `isClosed()` 方法
- [ ] 定义 `onCancellation()` 方法
- [ ] 编写接口文档（明确只用于 Runtime 资源）

#### 3.2 AsyncResourceManager 实现

**文件**: `src/Resource/AsyncResourceManager.php` (新建)

**任务**:
- [ ] 实现资源注册/注销机制
- [ ] 实现资源与 Scope 绑定
- [ ] 实现 Scope 结束时自动清理资源
- [ ] 实现资源泄漏检测
- [ ] 实现批量注册优化

**关键实现**:
```php
class AsyncResourceManager {
    private static array $resources = []; // scope_id => [resources]
    
    public static function register(AsyncResource $resource): void {
        $scope = CancellationScope::current();
        if (!$scope) {
            throw new \RuntimeException("No active CancellationScope");
        }
        $scopeId = spl_object_id($scope);
        self::$resources[$scopeId][] = $resource;
    }
    
    public static function cleanupScope(CancellationScope $scope): void {
        $scopeId = spl_object_id($scope);
        foreach (self::$resources[$scopeId] ?? [] as $resource) {
            $resource->close();
        }
        unset(self::$resources[$scopeId]);
    }
}
```

#### 3.3 Runtime 资源实现

**文件**: `src/Resource/` (新建多个资源类)

**任务**:
- [ ] 实现 `FiberResource`（Fiber 资源）
- [ ] 实现 `TimerResource`（Timer 资源）
- [ ] 实现 `ContextResource`（Context 资源）
- [ ] 集成到 EventLoop 和 Context 中

### Phase 4: Runtime 可观测性（2-3周）

#### 4.1 事件定义

**文件**: `src/Observable/Events/` (新建)

**任务**:
- [ ] 创建 `TaskEvent` 类
- [ ] 创建 `ScopeEvent` 类
- [ ] 创建 `ResourceEvent` 类
- [ ] 创建 `RuntimeStateEvent` 类
- [ ] 定义事件类型枚举

#### 4.2 Observer 接口

**文件**: `src/Observable/Observer.php` (新建)

**任务**:
- [ ] 定义 `Observer` 接口
- [ ] 定义事件处理方法
- [ ] 编写接口文档

#### 4.3 Observable 实现

**文件**: `src/Observable/Observable.php` (新建)

**任务**:
- [ ] 实现 Observer 注册/注销
- [ ] 实现事件发送机制
- [ ] 实现默认关闭（零开销）
- [ ] 实现事件过滤机制
- [ ] 实现性能优化（快速路径）

#### 4.4 内置 Observer

**文件**: `src/Observable/Observers/` (新建)

**任务**:
- [ ] 实现 `LogObserver`（日志记录）
- [ ] 实现 `StatsObserver`（统计收集）
- [ ] 实现 `TraceObserver`（调用链追踪）

#### 4.5 集成到核心

**文件**: `src/Core/EventLoop.php`, `src/Core/Task.php`, `src/Concurrency/CancellationScope.php`

**任务**:
- [ ] 在 Task 生命周期关键点发送事件
- [ ] 在 Scope 生命周期关键点发送事件
- [ ] 在资源注册/注销时发送事件
- [ ] 确保默认关闭时零开销

### Phase 5: 代码清理和重构（2周）

#### 5.1 移除业务相关代码

**任务**:
- [ ] 检查并移除所有 HTTP/数据库/Redis 相关代码（如果还在 core 中）
- [ ] 移除业务协议相关代码
- [ ] 清理 Monitor 相关代码（重构为 Observable）

#### 5.2 Context 自动清理优化

**文件**: `src/Core/Context.php`

**任务**:
- [ ] 实现自动清理机制（定期清理）
- [ ] 优化清理性能（延迟清理）
- [ ] 集成到 Scope 生命周期

#### 5.3 性能优化

**任务**:
- [ ] 优化 Scope 追踪（使用缓存）
- [ ] 优化资源管理（批量操作）
- [ ] 优化事件发送（快速路径）
- [ ] 性能基准测试

### Phase 6: 测试和文档（2-3周）

#### 6.1 单元测试

**任务**:
- [ ] 为所有新功能编写单元测试
- [ ] 测试覆盖率 > 90%
- [ ] 测试性能回归

#### 6.2 集成测试

**任务**:
- [ ] 测试结构化并发场景
- [ ] 测试资源管理场景
- [ ] 测试可观测性场景
- [ ] 测试长期运行稳定性

#### 6.3 文档编写

**任务**:
- [ ] 编写 API 文档（所有 @api-stable 接口）
- [ ] 编写迁移指南（v2.x → v3.0）
- [ ] 编写架构设计文档
- [ ] 编写性能优化指南
- [ ] 更新 README

#### 6.4 示例代码

**任务**:
- [ ] 创建结构化并发示例
- [ ] 创建资源管理示例
- [ ] 创建可观测性示例
- [ ] 更新现有示例

### Phase 7: 发布准备（1周）

#### 7.1 版本号管理

**任务**:
- [ ] 更新 `composer.json` 版本号
- [ ] 更新 CHANGELOG
- [ ] 创建 RELEASE_v3.0.0.md

#### 7.2 兼容性测试

**任务**:
- [ ] 测试与扩展包的兼容性
- [ ] 测试迁移工具
- [ ] 性能基准测试

#### 7.3 发布文档

**任务**:
- [ ] 编写发布说明
- [ ] 编写升级指南
- [ ] 编写破坏性变更说明

## 关键设计决策

### 1. 向后兼容性

**决策**: 允许破坏性变更，但提供清晰的迁移路径

**影响**:
- 核心 API（`run`, `create_task`, `await`, `gather`）保持兼容
- 行为可能变化（如 gather 语义）
- 内部 API 可能移除或变更

### 2. 性能优化策略

**决策**: 功能优先，性能优化在实现阶段进行

**措施**:
- Scope 追踪使用缓存
- 资源管理批量操作
- Observability 默认关闭
- 延迟清理机制

### 3. 测试策略

**决策**: 高测试覆盖率，性能基准测试

**目标**:
- 单元测试覆盖率 > 90%
- 性能基准测试套件
- 长期运行稳定性测试

## 风险与应对

### 风险 1: 性能回归

**应对**:
- 建立性能基准测试
- 持续监控性能指标
- 优化关键路径

### 风险 2: 迁移成本

**应对**:
- 提供详细的迁移指南
- 提供迁移工具
- 保持核心 API 兼容

### 风险 3: API 设计争议

**应对**:
- 充分讨论设计
- 提供 RFC 文档
- 收集社区反馈

## 成功标准

### 技术指标

- [ ] 核心 API 100% 冻结（@api-stable）
- [ ] 所有 Task 都有 Scope 追踪
- [ ] 所有 Runtime 资源都有生命周期管理
- [ ] 测试覆盖率 > 90%
- [ ] 性能与 v2.x 持平（±10%）

### 质量指标

- [ ] API 文档完整
- [ ] 迁移指南清晰
- [ ] 示例代码充足
- [ ] 社区反馈积极

## 时间估算

- Phase 1: 2-3周
- Phase 2: 3-4周
- Phase 3: 2-3周
- Phase 4: 2-3周
- Phase 5: 2周
- Phase 6: 2-3周
- Phase 7: 1周

**总计**: 14-19周（约 3.5-5 个月）

## 下一步行动

1. 确认计划细节
2. 开始 Phase 1: 核心抽象冻结
3. 建立性能基准测试

---

**文档版本**: v1.0  
**创建日期**: 2025-01-24  
**最后更新**: 2025-01-24

